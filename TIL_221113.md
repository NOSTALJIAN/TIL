# **❤️‍🔥 TIL DAY 04 ❤️‍🔥**

> 📆 2022년 11월 13일 일요일

<br>

---

<br>

TStoryBlog에 Java 이론 혼자 공부하면서 적어뒀던 문서들 가져오기 😭 <br>

<br>

---

<br>

## **❓ Java의 특징**

💡 **이식성이 높은 언어이다.**

    자바로 개발된 프로그램은 소스파일을 수정하지 않아도
    자바 실행 환경(JRE : Java Runtime Environment)이 설치되어 있다면
    모든 운영체제에서 실행 가능하다.

<br>

💡 **객체지향 언어이다.**

    처음부터 객체를 고려하여 설계된 언어이기 때문에
    객체지향 언어가 가져야 할 캡슐화, 상속, 다형성 기능을 완벽하게 지원한다.

<br>

💡 **함수적 스타일 코딩을 지원한다.**

    함수적 프로그래밍은 대용량 데이터의 병렬 처리, 이벤트 지향 프로그래밍을 할 때 유용한데, 
    자바는 함수적 프로그래밍을 위해 람다식(Lamda Expression)을 자바 8부터 지원한다.

<br>

💡 **메모리를 자동으로 관리한다.**

    C++ 같은 언어의 경우 개발자가 직접 메모리를 관리해줘야한다.
    메모리를 제대로 관리해주지 않으면 프로그램에 오류가 발생할 수 있다.

    하지만 자바의 경우엔 객체 생성 시 자동으로 메모리 영역을 찾아서 할당해주고,
    사용이 완료되면 쓰레기 수집기(Garbage Collector)를 실행시켜 자동으로 사용하지 않는 객체를 제거시켜준다.
    그렇기에 개발자들이 메모리 관리를 신경 쓰지 않아도 되고 프로그램의 안정성이 높아진다.

<br>

💡 **다양한 애플리케이션을 개발할 수 있다.**

    자바는 다양한 운영체제에서 실행되는 프로그램을 개발할 수 있다.

<br>

💡 **멀티 스레드(Multi-Thread)를 쉽게 구현할 수 있다.**

    프로그램이 실행되는 운영체제에 따라 멀티 스레드를 구현하는 방법이 다르지만,
    자바는 멀티 스레드 관련 라이브러리 API를 제공하고 있기 때문에
    실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다.

<br>

💡 **동적 로딩(Dynamic Loading)을 지원한다.**

    자바 애플리케이션이 실행될 때 모든 객체가 생성되지 않고,
    객체가 필요한 시점에 클래스를 동적 로딩해서 객체를 생성한다.
    나중에 유지보수를 할 때도 해당 클래스만 수정하면 되므로
    유지보수를 쉽고 빠르게 진행할 수 있다.

<br>

💡 **막강한 오픈소스라이브러리가 풍부하다.**

    자바는 오픈소스 언어이기 때문에 자바에서 사용하는 라이브러리 또한 오픈소스가 넘쳐난다.
    오픈소스 라이브러리를 사용하면 안전하게 빨리 개발을 할 수 있다.

<br>

---

<br>

## ❓ **자바 가상 기계 (JVM)**

자바 프로그램은 **자바 가상 기계 `JVM : Java Virtual Machine`** 위에서 돌아간다. <br>
왜냐하면 운영체제는 자바 프로그램을 바로 실행시킬 수 없기 때문이다.  <br>
<br>
자바 프로그램은 바이트 코드이기 때문에 <br>
중간에서 JVM이 **바이트 코드를 기계어로 바꿔준다.** <br>
또한, 자바 프로그램은 JVM 위에서 돌아가기 때문에 <br>
자바 프로그램을 운영체제마다 따로따로 만들어 줄 필요가 없다. <br>
물론 자바 프로그램은 운영체제와 상관없지만, JVM은 운영체제에 종속적이다. <br>
<br>
자바 프로그램은 확장자가 `.java`인 소스 파일을 작성하는 것부터 시작한다. <br>
이 소스 파일은 컴퍼일러 `javac.exe`로 컴파일하면 <br>
확장자가 `.class`인 바이트 코드 파일이 생성된다. <br>
바이트 코드 파일은 JVM 구동 명령어 `java.exe`에 의해 JVM에서 해석되고 <br>
해당 운영체제에 맞게 기계어로 번역된다. <br>

<br>

---

<br>

## ❓ **개발 순서**

<br>

### 1️⃣ `.java` 소스 파일 작성

### 2️⃣ 컴파일러 `javac.exe`로 바이트 코드 파일 `.class` 생성

### 3️⃣ JVM 구동 명령어 `java.exe`로 실행

<br>

---

<br>

## ❓ **`class{}`, `main()`, `method()`**

      public class Hello {
        public static voic main(String[] args) {
        System.out.println("Hello, welcome to the java world!");
        }
      }

→ *"Hello, welcome to the java world!"* 출력

<br>

- **`class{}`**: 필드 또는 메소드를 **포함**
- **`method()`**: 실행문
- **Example** <br>
  
      public class Hello {
      }

  → `Hello` : class 이름 <br>
  → `method()` : 반드시 class의 {} 안에 포함 <br>

<br>

클래스의 이름은 개발자가 마음대로 정할 수 있다. 다만 소스 파일명과 대소문자가 일치해야 한다. 그리고 숫자로 시작할 수 없고, 공백을 포함해서도 안 된다.

클래스 블록에는 메소드를 작성할 수 있는데, 메소드는 클래스처럼 이름과 블록을 가진다. main이 메소드 이름이고, 중괄호부터 그와 짝을 이루는 중괄호까지가 메소드 블록이다.

```
public static void main(String[] args) { // main은 메소드 이름, 중괄호부터 메소드 블록 시작
 System.out.println("Hello, welcome to the java world!");
} // 여기까지 메소드 블록
```

메소드 이름도 개발자가 마음대로 정할 수 있지만 **main() 메소드 만큼은 다른 이름으로 바꾸면 안 된다.** 왜냐하면 java.exe로 JVM을 구동시키면 제일 먼저 main() 메소드를 찾아서 실행시키기 때문이다. 그래서 main() 메소드를 프로그램 실행 진입점(entry point)이라고 한다. 만약 클래스 내부에 main() 메소드가 없거나 잘못 작성하면 클래스를 실행할 수 없다. main() 메소드가 없는 클래스를 실행시키면 에러 메세지가 뜬다.

메소드 블록에는 실행문이 작성되는데, 실행문의 끝에는 반드시 세미콜론(;)을 붙여야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

System.out.println("Hello, welcome to the java world!");  실행문으로 인해 문자열이 출력된다.

main() 메소드 블록이 모두 실행되면 Hello 프로그램은 종료된다.

---

## **주석**

주석은 프로그램 실행과는 상관없이 코드에 설명을 붙인 것을 말한다. 컴파일 과정에서 주석은 무시되고 실행문만 바이트 코드로 번역된다.

| 주석기호 | 설명 |
| --- | --- |
| // | // 부터 라인 끝까지 주석으로 처리한다. (행 주석) |
| /\* ~ \*/ | /\* 와 \*/ 사이에 있는 모든 범위를 주석으로 처리한다. (범위 주석) |

행 주석과 범위 주석 외에도 자바 API 도큐먼트 문서에 포함되는 도큐먼트 주석(/\*\* ~ \*/)도 있다. 도큐먼트 주석은 javadoc.exe 명령어로 API 도큐먼트를 생성하는 데 사용된다.
<!--END-->